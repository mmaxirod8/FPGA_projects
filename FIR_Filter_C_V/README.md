# üì∂ FIR Filter: Image Sharpening (Cyclone V)

This directory contains the hardware implementation of an FIR (Finite Impulse Response) filter configured as an image sharpening filter for real-time image processing on a Cyclone V FPGA.
## üìÇ Folder Content

* **`VHDL Files/`**: VHDL source code. Includes:
    * `sharp.vhd`: Top entity del filtro.
    * `sharp_slice.vhd`, `sharp_linemem.vhd`: Line buffer logic and slices for pixel window processing.
    * `sharp_control.vhd`: State machine for flow control.
    * `sim_*.vhd`: Testbenches for simulation (including *self-checking*).
* **`Octave testing/`**: MATLAB/Octave scripts (`.m`) used to generate the test stimuli and mathematically verify the algorithm (open them with NotePad++ or text editor).
* **`Octave Images/`**: Input images (Bitmaps) and results generated by the test scripts.
* **Root Files**:
    * `sharp.sdc`: Time constraints file (Synopsys Design Constraints).
    * `sharp_default_Cyclone_V.qsf`: Pin configuration and project for Quartus Prime.

## üöÄ How to use this project

The workflow is hybrid, using Octave to pre-process the images and ModelSim for hardware simulation.

1. **Generate Self-Testbench:** Run the script `sharp_generate_testbench_images.m` (opening it with Notepad++ or another text editor, and copying the code into Octave/MatLab). This code does the following:
- Apply FIR Filter to the input image [image stimulation] (which will consequently generate an output image [image expected])
- Transform both images (input and output) into PPM format images with ASCII encoding (necessary for the FPGA to "read" during the simulation). Basically, it will take the image to which we want to apply the FIR Filter from the folder (where the script or .m file is located, which must be in the same location as the image to be processed) and generate two files (PPM input image and PPM output image [FIR Filter Applied]).
**The image names must be changed both in the script to be implemented and in the VHD testbench file (`sim_sharp.vhd`)**
2. **HDL Simulation:** Open the project in ModelSim, compile the files in `VHDL Files/`, and run the testbench `sim_sharp.vhd`.
3. **Quartus Synthesis & FPGA Implementation:** After simulating in ModelSim and verifying the code's functionality, we will proceed to implement all the `VHDL Files/` plus the `.qsf` file of the board to be used (pin map) in Altera Quartus Prime (by executing "Synthesis"). From here, we will obtain the `.sof` bitfile (located in the `output_files` directory of your Quartus-Project on our computer), and with this, we are ready to implement our algorithm on a remote or physical FPGA.
4. **Cross Validation:** The script `sharp_image_filter.m` contains the algorithm to be implemented. You can compare the FPGA simulation output with the output generated by this script to ensure that the hardware behaves exactly as the mathematical model describes. Essentially, this is a verification of the algorithm we want the FPGA to perform, and a quick way to check if the algorithm performs as expected using Octave/MATLAB for later implementation on the board.
  
## üõ†Ô∏è Verification Tools (Octave Scripts)

Unlike previous C projects, this design uses high-level scripts (`.m`) to automate data flow.

### Main Functions
* **`sharp_generate_testbench_images.m`**:
    * It acts as a bridge between the world of images (`.bmp`, `.jpg`) and the digital world.
    * It converts the image's pixel matrix into test vectors compatible with the VHDL Testbench.

* **`sharp_image_filter.m`**:
    * Implements the sharpness filter convolution algorithm in software.
    * Validates that the arithmetic logic (`sharp_arith.vhd`) implemented in the FPGA calculates the correct pixel values, handling overflows and saturation in the same way as the hardware.

* **`write_ascii_ppm.m`**:
    * Utility to export visual results in PPM (Portable Pixel Map) format, facilitating quick visualization of the simulation output without the need for complex viewers.
